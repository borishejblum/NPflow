# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' C++ implementation of the F-measure computation
#' 
#'@param pred
#'@param ref
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'similarityMatC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:100){
#'     c2 <- c(c2, list(rmultinom(n=1, size=3000, prob=rexp(n=3000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             similarityMatC(c3)}
#'microbenchmark(f(), time=1L)
#'
FmeasureC <- function(pred, ref) {
    .Call('NPflow_FmeasureC', PACKAGE = 'NPflow', pred, ref)
}

#' C++ implementation of cost computation with Fmeasure as loss function
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'Fmeasure_costC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:500){
#'     c2 <- c(c2, list(rmultinom(n=1, size=10000, prob=rexp(n=10000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             Fmeasure_costC(c3)}
#'fa <- function(){c3 <-sapply(c2, "[")
#'             Fmeasure_costC_arma(c3)}
#'microbenchmark(f(), fa(), times=10L)
#'
Fmeasure_costC <- function(c) {
    .Call('NPflow_Fmeasure_costC', PACKAGE = 'NPflow', c)
}

#' C++ implementation of cost computation with Fmeasure as loss function
#' using the Armadillo library
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
Fmeasure_costC_arma <- function(c) {
    .Call('NPflow_Fmeasure_costC_arma', PACKAGE = 'NPflow', c)
}

#' Parallel C++ implementation of the F-measure computation
#' 
#'@param pred
#'@param ref
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'similarityMatC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:100){
#'     c2 <- c(c2, list(rmultinom(n=1, size=3000, prob=rexp(n=3000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             similarityMatC(c3)}
#'microbenchmark(f(), time=1L)
#'
FmeasureC_par <- function(pred, ref, ncores = 1L) {
    .Call('NPflow_FmeasureC_par', PACKAGE = 'NPflow', pred, ref, ncores)
}

#' Parallel C++ implementation of cost computation with Fmeasure as loss function
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'Fmeasure_costC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:500){
#'     c2 <- c(c2, list(rmultinom(n=1, size=10000, prob=rexp(n=10000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             Fmeasure_costC(c3)}
#'fa <- function(){c3 <-sapply(c2, "[")
#'             Fmeasure_costC_arma(c3)}
#'microbenchmark(f(), fa(), times=10L)
#'
Fmeasure_costC_par <- function(c, ncores = 1L) {
    .Call('NPflow_Fmeasure_costC_par', PACKAGE = 'NPflow', c, ncores)
}

#' Parallel C++ implementation of cost computation with Fmeasure as loss function
#' using the Armadillo library
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
Fmeasure_costC_arma_par <- function(c, ncores = 1L) {
    .Call('NPflow_Fmeasure_costC_arma_par', PACKAGE = 'NPflow', c, ncores)
}

#' C++ implementation of multivariate log gamma function
#' 
#'@param x strictly positive real number
#'@param p integer
#'
#'@export
#'
lgamma_mvC <- function(x, p) {
    .Call('NPflow_lgamma_mvC', PACKAGE = 'NPflow', x, p)
}

#' C++ implementation of multivariate structured Normal inverse Wishart probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param psi skew parameter vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export
#'
#'
mmsNiWpdfC <- function(xi, psi, Sigma, U_xi0, U_psi0, U_B0, U_Sigma0, U_df0, Log = TRUE) {
    .Call('NPflow_mmsNiWpdfC', PACKAGE = 'NPflow', xi, psi, Sigma, U_xi0, U_psi0, U_B0, U_Sigma0, U_df0, Log)
}

#' C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param mean mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'library(microbenchmark)
#'microbenchmark(mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mmvnpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), Log=FALSE),
#'               times=10000L)
#'microbenchmark(mvnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), mean=c(0, 0), varcovM=diag(2), Log=FALSE),
#'               mvnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), mean=c(0, 0), varcovM=diag(2), Log=FALSE),
#'               mmvnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'                        mean=matrix(c(0, 0), nrow=2, ncol=1), 
#'                        varcovM=list(diag(2)), Log=FALSE),
#'               times=10000L)
#'microbenchmark(mvnpdf(x=matrix(c(rep(1.96,2),rep(0,2)), nrow=2, ncol=2), 
#'                      mean=list(c(0,0),c(-1,-1), c(1.5,1.5)),
#'                      varcovM=list(diag(2),10*diag(2), 20*diag(2)), Log=FALSE),
#'               mmvnpdfC(matrix(c(rep(1.96,2),rep(0,2)), nrow=2, ncol=2), 
#'                      mean=matrix(c(0,0,-1,-1, 1.5,1.5), nrow=2, ncol=3),
#'                      varcovM=list(diag(2),10*diag(2), 20*diag(2)), Log=FALSE),
#'               times=10000L)
#'
mmvnpdfC <- function(x, mean, varcovM, Log = TRUE) {
    .Call('NPflow_mmvnpdfC', PACKAGE = 'NPflow', x, mean, varcovM, Log)
}

#' Parallel C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param mean mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'#NB: change ~/.R/Makevars 'CC' and 'CXX' to set the compiler 
#'#either to 'gcc' and 'g++', or to 'clang' and 'clang++'
#'library(microbenchmark)
#'
#'K=1000
#'d=10
#'z_mat <- NULL
#'m_list <- list()
#'m_mat <- NULL
#'S_list <- list()
#'
#'for(i in 1:K){
#' z_mat <- c(z_mat, c(rep(1.96,d)))
#' m_list <- c(m_list, list(c(rep(-1.5,d))))
#' m_mat <- c(m_mat, c(rep(-1.5,d)))
#' S_list <- c(S_list, list(0.33*diag(d)))
#' }
#' z_mat <- matrix(z_mat, ncol=K, nrow=d)
#' m_mat <- matrix(m_mat, ncol=K, nrow=d)
#'
#'microbenchmark(mvnpdf(x=z_mat, mean=m_list, varcovM=S_list, Log=FALSE),
#'               mmvnpdfC(x=z_mat, mean=m_mat, varcovM=S_list, Log=FALSE),
#'               mmvnpdfC_par(x=z_mat, mean=m_mat, varcovM=S_list, Log=FALSE, 
#'                      ncores = 2),
#'               times=10L)
#'
mmvnpdfC_par <- function(x, mean, varcovM, Log = TRUE, ncores = 1L) {
    .Call('NPflow_mmvnpdfC_par', PACKAGE = 'NPflow', x, mean, varcovM, Log, ncores)
}

#' C++ implementation of multivariate skew Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param psi skew parameter vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export 
#'@examples
#'mmvsnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2)), Log=FALSE
#'          )
#'mmvsnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2))
#'          )
#'          
#'library(microbenchmark)
#'microbenchmark(mvsnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), xi=c(0, 0), psi=c(1, 1), sigma=diag(2), Log=FALSE),
#'               mmvsnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2)), Log=FALSE),
#'               times=10000L
#'              )
#'microbenchmark(mvsnpdf(x=matrix(c(rep(1.96,2),rep(0,2)), nrow=2, ncol=2), 
#'                      xi=list(c(0,0),c(-1,-1), c(1.5,1.5)),
#'                      psi=list(c(0.1,0.1),c(-0.1,-1), c(0.5,-1.5)),
#'                      sigma=list(diag(2),10*diag(2), 20*diag(2)), Log=FALSE),
#'               mmvsnpdfC(matrix(c(rep(1.96,2),rep(0,2)), nrow=2, ncol=2), 
#'                      xi=matrix(c(0,0,-1,-1, 1.5,1.5), nrow=2, ncol=3), 
#'                      psi=matrix(c(0.1,0.1,-0.1,-1, 0.5,-1.5), nrow=2, ncol=3),
#'                      sigma=list(diag(2),10*diag(2), 20*diag(2)), Log=FALSE),
#'               times=10000L)
#'              
mmvsnpdfC <- function(x, xi, psi, sigma, Log = TRUE) {
    .Call('NPflow_mmvsnpdfC', PACKAGE = 'NPflow', x, xi, psi, sigma, Log)
}

#' Parallel C++ implementation of multivariate skew Normal probability density function for multiple inputs
#' 
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param psi skew parameter vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@param ncores integer number of cores to be used in parallel
#'@return matrix of densities of dimension K x n
#'@export 
#'@examples
#'library(microbenchmark)
#'
#'K=1000
#'d=10
#'z_mat <- NULL
#'xi_list <- list()
#'xi_mat <- NULL
#'psi_list <- list()
#'psi_mat <- NULL
#'S_list <- list()
#'
#'for(i in 1:K){
#' z_mat <- c(z_mat, c(rep(1.96,d)))
#' xi_list <- c(xi_list, list(c(rep(-1.5,d))))
#' xi_mat <- c(xi_mat, c(rep(-1.5,d)))
#' psi_list <- c(psi_list, list(c(rep(-0.2,d))))
#' psi_mat <- c(psi_mat, c(rep(-0.2,d)))
#' S_list <- c(S_list, list(0.33*diag(d)))
#' }
#' z_mat <- matrix(z_mat, ncol=K, nrow=d)
#' xi_mat <- matrix(xi_mat, ncol=K, nrow=d)
#' psi_mat <- matrix(psi_mat, ncol=K, nrow=d)
#'
#'microbenchmark(mvsnpdf(x=z_mat, xi=xi_list, psi=psi_list, sigma=S_list, Log=FALSE),
#'               mmvsnpdfC(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, Log=FALSE),
#'               mmvsnpdfC_par(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, Log=FALSE, 
#'                      ncores = 2),
#'               times=10L)
#'microbenchmark(mmvsnpdfC(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, Log=FALSE),
#'               mmvsnpdfC_par(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, Log=FALSE, 
#'                      ncores = 4),
#'               times=100L)
#'               
#'              
mmvsnpdfC_par <- function(x, xi, psi, sigma, Log = TRUE, ncores = 1L) {
    .Call('NPflow_mmvsnpdfC_par', PACKAGE = 'NPflow', x, xi, psi, sigma, Log, ncores)
}

#' C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param psi skew parameter vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'
#'mmvstpdfC(x = matrix(c(3.399890,-5.936962), ncol=1), xi=matrix(c(0.2528859,-2.4234067), ncol=1), 
#'psi=matrix(c(11.20536,-12.51052), ncol=1), 
#'sigma=list(matrix(c(0.2134011, -0.2382573, -0.2382573, 0.2660086), ncol=2)), 
#'df=c(7.784106)
#')
#'mvstpdf(x = matrix(c(3.399890,-5.936962), ncol=1), xi=matrix(c(0.2528859,-2.4234067), ncol=1), 
#'psi=matrix(c(11.20536,-12.51052), ncol=1), 
#'sigma=list(matrix(c(0.2134011, -0.2382573, -0.2382573, 0.2660086), ncol=2)), 
#'df=c(7.784106)
#')
#'
#'#skew-normal limit
#'mmvsnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2))
#'          )
#'mvstpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'        xi=c(0, 0), psi=c(1, 1), sigma=diag(2),
#'        df=100000000
#'        )
#'mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2)),
#'          df=100000000
#'          )
#'          
#'#non-skewed limit         
#'mmvtpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'         mean=matrix(c(0, 0)), varcovM=list(diag(2)),
#'         df=10
#'         )
#'mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(0, 0),ncol=1), sigma=list(diag(2)),
#'          df=10
#'          )
#'
#'library(microbenchmark)
#'microbenchmark(mvstpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'                       xi=c(0, 0), psi=c(1, 1), 
#'                       sigma=diag(2), df=10),
#'               mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'                         xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), 
#'                         sigma=list(diag(2)), df=10),
#'               times=10000L)
#'
mmvstpdfC <- function(x, xi, psi, sigma, df, Log = TRUE) {
    .Call('NPflow_mmvstpdfC', PACKAGE = 'NPflow', x, xi, psi, sigma, df, Log)
}

#' ParallelC++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param psi skew parameter vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'
#'K=1000
#'d=10
#'z_mat <- NULL
#'xi_list <- list()
#'xi_mat <- NULL
#'psi_list <- list()
#'psi_mat <- NULL
#'S_list <- list()
#'
#'for(i in 1:K){
#' z_mat <- c(z_mat, c(rep(1.96,d)))
#' xi_list <- c(xi_list, list(c(rep(-1.5,d))))
#' xi_mat <- c(xi_mat, c(rep(-1.5,d)))
#' psi_list <- c(psi_list, list(c(rep(-0.2,d))))
#' psi_mat <- c(psi_mat, c(rep(-0.2,d)))
#' S_list <- c(S_list, list(0.33*diag(d)))
#' }
#' z_mat <- matrix(z_mat, ncol=K, nrow=d)
#' xi_mat <- matrix(xi_mat, ncol=K, nrow=d)
#' psi_mat <- matrix(psi_mat, ncol=K, nrow=d)
#'
#'library(microbenchmark)
#'microbenchmark(mmvstpdfC(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, df=rep(10,K), Log=FALSE),
#'               mmvstpdfC_par(x=z_mat, xi=xi_mat, psi=psi_mat, sigma=S_list, df=rep(10,K),  Log=FALSE, 
#'                      ncores = 4),
#'               times=50L)
#'
mmvstpdfC_par <- function(x, xi, psi, sigma, df, Log = TRUE, ncores = 1L) {
    .Call('NPflow_mmvstpdfC_par', PACKAGE = 'NPflow', x, xi, psi, sigma, df, Log, ncores)
}

#' C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param mean mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10000000, Log=FALSE)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10000000, Log=FALSE)
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1))
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10000000)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10000000)
#'
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10)
#'
#'
#'library(microbenchmark)
#'microbenchmark(mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               #mvpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), Log=FALSE),
#'               times=10000L)
#'
mmvtpdfC <- function(x, mean, varcovM, df, Log = TRUE) {
    .Call('NPflow_mmvtpdfC', PACKAGE = 'NPflow', x, mean, varcovM, df, Log)
}

#' Parallel C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param mean mean vectors matrix of dimension p x K, K being the number of 
#'distributions for which the density probability has to be ealuated
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}.
#'@return matrix of densities of dimension K x n
#'@export
#'@examples
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10000000, Log=FALSE)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10000000, Log=FALSE)
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1))
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10000000)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10000000)
#'
#'mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), df=10)
#'mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), df=10)
#'
#'
#'library(microbenchmark)
#'microbenchmark(mvtpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               #mvpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mmvtpdfC(x=matrix(1.96), mean=matrix(0), varcovM=list(diag(1)), Log=FALSE),
#'               times=10000L)
#'
mmvtpdfC_par <- function(x, mean, varcovM, df, Log = TRUE, ncores = 1L) {
    .Call('NPflow_mmvtpdfC_par', PACKAGE = 'NPflow', x, mean, varcovM, df, Log, ncores)
}

#' C++ implementation of multivariate Normal probability density function
#' 
#'Based on the implementation from Nino Hardt and Dicko Ahmadou
#'http://gallery.rcpp.org/articles/dmvnorm_arma/ 
#'(accessed in August 2014)
#'
#'@param x data matrix
#'@param mean mean vector
#'@param varcovM variance covariance matrix
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}
#'@return vector of densities
#'
#'@export
#'
#'@examples
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1))
#'mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1))
#'
#'library(microbenchmark)
#'microbenchmark(mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               times=10000L)     
#'               
mvnpdfC <- function(x, mean, varcovM, Log = TRUE) {
    .Call('NPflow_mvnpdfC', PACKAGE = 'NPflow', x, mean, varcovM, Log)
}

#' Parallel C++ implementation of multivariate Normal probability density function
#' 
#'Based on the implementation from Nino Hardt and Dicko Ahmadou
#'http://gallery.rcpp.org/articles/dmvnorm_arma/ 
#'(accessed in August 2014)
#'
#'@param x data matrix
#'@param mean mean vector
#'@param varcovM variance covariance matrix
#'@param logical flag for returning the log of the probability density 
#'function. Defaults is \code{TRUE}
#'@return vector of densities
#'
#'@export
#'
#'@examples
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE)
#'mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1))
#'mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1))
#'
#'library(microbenchmark)
#'microbenchmark(mvnpdf(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               mvnpdfC(x=matrix(1.96), mean=0, varcovM=diag(1), Log=FALSE),
#'               times=10000L)     
#'               
mvnpdfC_par <- function(x, mean, varcovM, Log = TRUE, ncores = 1L) {
    .Call('NPflow_mvnpdfC_par', PACKAGE = 'NPflow', x, mean, varcovM, Log, ncores)
}

#' C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param c integer vector of cluster allocations with values from 1 to K
#'@param clustval vector of unique values from c in the order corresponding to 
#'the storage of cluster parameters in \code{xi}, \code{psi}, and \code{varcovM}
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'clusters
#'@param psi skew parameter vectors matrix of dimension p x K
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@return a list: "indiv": vector of likelihood of length n; "clust": vector of likelihood of length K; "total": total (log)-likelihood
#'@seealso mmvstpdfC, mvstpdf
#'@export
#'@examples
#'
#'#skew-normal limit
#'mmvsnpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2))
#'          )
#'mvstpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'        xi=c(0, 0), psi=c(1, 1), sigma=diag(2),
#'        df=100000000
#'        )
#'mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), sigma=list(diag(2)),
#'          df=100000000
#'          )
#'          
#'#non-skewed limit         
#'mmvtpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'         mean=matrix(c(0, 0)), varcovM=list(diag(2)),
#'         df=10
#'         )
#'mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'          xi=matrix(c(0, 0)), psi=matrix(c(0, 0),ncol=1), sigma=list(diag(2)),
#'          df=10
#'          )
#'          
#'microbenchmark(mvstpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), 
#'                       xi=c(0, 0), psi=c(1, 1), 
#'                       sigma=diag(2), df=10),
#'               mmvstpdfC(x=matrix(rep(1.96,2), nrow=2, ncol=1),
#'                         xi=matrix(c(0, 0)), psi=matrix(c(1, 1),ncol=1), 
#'                         sigma=list(diag(2)), df=10),
#'               times=10000L)
#'
mvstlikC <- function(x, c, clustval, xi, psi, sigma, df, loglik = TRUE) {
    .Call('NPflow_mvstlikC', PACKAGE = 'NPflow', x, c, clustval, xi, psi, sigma, df, loglik)
}

#' Parallel C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension p x n, p being the dimension of the 
#'data and n the number of data points 
#'@param c integer vector of cluster allocations with values from 1 to K
#'@param clustval vector of unique values from c in the order corresponding to 
#'the storage of cluster parameters in \code{xi}, \code{psi}, and \code{varcovM}
#'@param xi mean vectors matrix of dimension p x K, K being the number of 
#'clusters
#'@param psi skew parameter vectors matrix of dimension p x K
#'@param varcovM list of length K of variance-covariance matrices, 
#'each of dimensions p x p
#'@param df vector of length K of degree of freedom parameters
#'@return a list: "indiv": vector of likelihood of length n; "clust": vector of likelihood of length K; "total": total (log)-likelihood
#'@seealso mmvstpdfC, mvstpdf
#'@export
mvstlikC_par <- function(x, c, clustval, xi, psi, sigma, df, loglik = TRUE, ncores = 1L) {
    .Call('NPflow_mvstlikC_par', PACKAGE = 'NPflow', x, c, clustval, xi, psi, sigma, df, loglik, ncores)
}

#' C++ implementation
#' 
#'
#'@param \code{c} is an MCMC partitions of length \code{n}.
#'
#'@param \code{d} is a symmetric \code{n x n} matrix containing distances
#'between each group distributions.
#'
#'@export
#'
#'@examples
#'c <- c(1,1,2,3,2,3)
#'d <- matrix(runif(length(c)^2),length(c))
#'NuMatParC(c,d)
#'
#'
NuMatParC <- function(c, d) {
    .Call('NPflow_NuMatParC', PACKAGE = 'NPflow', c, d)
}

#' C++ implementation of the multinomial sampling from a matrix 
#' of column vectors each containing the sampling probabilities 
#' for their respective draw
#' 
#'@param probMat
#'@keywords internal
#'
#'@export
#'
sampleClassC <- function(probMat) {
    .Call('NPflow_sampleClassC', PACKAGE = 'NPflow', probMat)
}

#' C++ implementation of the multinomial sampling from a matrix 
#' of column vectors each containing the sampling probabilities 
#' for their respective draw
#' 
#' @details Slower than sampleClassC
#' 
#'@param probMat
#'@keywords internal
#'
#'@export
#'
sampleClassC_bis <- function(probMat) {
    .Call('NPflow_sampleClassC_bis', PACKAGE = 'NPflow', probMat)
}

#' Parallel C++ implementation of the multinomial sampling from a matrix 
#' of column vectors each containing the sampling probabilities 
#' for their respective draw
#' 
#' @details Slower than sampleClassC
#' 
#'@param probMat
#'@keywords internal
#'
#'@export
#'
sampleClassC_bis_par <- function(probMat, ncores = 1L) {
    .Call('NPflow_sampleClassC_bis_par', PACKAGE = 'NPflow', probMat, ncores)
}

#' Parallel C++ implementation of the multinomial sampling from a matrix 
#' of column vectors each containing the sampling probabilities 
#' for their respective draw
#' 
#'@param probMat
#'@keywords internal
#'
#'@export
#'
sampleClassC_par <- function(probMat, ncores = 1L) {
    .Call('NPflow_sampleClassC_par', PACKAGE = 'NPflow', probMat, ncores)
}

#' C++ implementation
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'similarityMat2C(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:100){
#'     c2 <- c(c2, list(rmultinom(n=1, size=3000, prob=rexp(n=3000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             similarityMat2C(c3)}
#'microbenchmark(f(), time=1L)
#'
similarityMat2C <- function(c) {
    .Call('NPflow_similarityMat2C', PACKAGE = 'NPflow', c)
}

#' C++ implementation
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'similarityMatC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:100){
#'     c2 <- c(c2, list(rmultinom(n=1, size=3000, prob=rexp(n=3000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             similarityMatC(c3)}
#'microbenchmark(f(), time=1L)
#'
similarityMatC <- function(c) {
    .Call('NPflow_similarityMatC', PACKAGE = 'NPflow', c)
}

#' Parallel C++ implementation
#' 
#'
#'@param c list of MCMC partitions
#'
#'@export
#'
#'@examples
#'c <- list(c(1,1,2,3,2,3), c(1,1,1,2,3,3),c(2,2,1,1,1,1))
#'similarityMatC(sapply(c, "["))
#'
#'c2 <- list()
#'for(i in 1:100){
#'     c2 <- c(c2, list(rmultinom(n=1, size=3000, prob=rexp(n=3000))))
#'}
#'library(microbenchmark)
#'f <- function(){c3 <-sapply(c2, "[")
#'             similarityMatC(c3)}
#'microbenchmark(f(), time=1L)
#'
#'
similarityMatC_par <- function(c, ncores = 1L) {
    .Call('NPflow_similarityMatC_par', PACKAGE = 'NPflow', c, ncores)
}

#' C++ implementation of residual trace computation step used when sampling the scale
#' 
#'@param eps
#'@keywords internal
#'
#'@export
#'
traceEpsC <- function(eps, sigma) {
    .Call('NPflow_traceEpsC', PACKAGE = 'NPflow', eps, sigma)
}

#' Parallel C++ implementation of residual trace computation step used when sampling the scale
#' 
#'@param eps
#'@keywords internal
#'
#'@export
#'
traceEpsC_par <- function(eps, sigma, ncores = 1L) {
    .Call('NPflow_traceEpsC_par', PACKAGE = 'NPflow', eps, sigma, ncores)
}

#' C++ implementation
#' 
#'
#'@param c is an MCMC partition
#'
#'@export
#'
#'@examples
#'c <- c(1,1,2,3,2,3))
#'vclust2mcoclustC(c)
#'
#'
vclust2mcoclustC <- function(c) {
    .Call('NPflow_vclust2mcoclustC', PACKAGE = 'NPflow', c)
}

